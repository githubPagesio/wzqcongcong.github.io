<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闷骚的悟空</title>
  
  <subtitle>立一业谋生|择一城终老|携一人白首</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zongquan.wang/"/>
  <updated>2017-11-02T12:04:29.000Z</updated>
  <id>https://zongquan.wang/</id>
  
  <author>
    <name>闷骚的悟空</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hack Cornerstone to load more logs</title>
    <link href="https://zongquan.wang/2017/11/02/Hack_Cornerstone_to_load_more_logs/"/>
    <id>https://zongquan.wang/2017/11/02/Hack_Cornerstone_to_load_more_logs/</id>
    <published>2017-11-02T09:51:44.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Cornerstone 每次只能 load 50 条 logs，所以想看 log 的时候，需要频繁点击 load 按钮，非常麻烦。</p><p>用 Hopper Disassembler 分析了一下它的代码，发现下面几处被 hardcode 成了 50：</p><ul><li><p><code>[V4LogTableViewController init]</code></p></li><li><p><code>[V4LogTableViewController controller]</code></p></li><li><p><code>[V4Log init]</code></p></li><li><p><code>[V4Log log]</code></p></li></ul><p>将这些函数里面的 <code>mov edx, 0x32</code> 改成 <code>mov edx, 0xff</code>，这样每次就可以 load 255 条 logs 了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Cornerstone 每次只能 load 50 条 logs，所以想看 log 的时候，需要频繁点击 load 按钮，非常麻烦。&lt;/p&gt;
&lt;p&gt;用 Hopper Disassembler 分析了一下它的代码，发现下面几处被 hardcode 成了 50：&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Mac" scheme="https://zongquan.wang/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>How to solve codesign issue &quot;signature too large to embed&quot;</title>
    <link href="https://zongquan.wang/2017/08/22/Signature_too_large_to_embed/"/>
    <id>https://zongquan.wang/2017/08/22/Signature_too_large_to_embed/</id>
    <published>2017-08-22T09:30:52.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在更换了苹果开发者证书后，用 <em>codesign</em> 签名时会报错：<em>signature too large to embed</em>。大意就是签名数据太大，超出了限制。</p><p><strong>根本原因</strong></p><p>通过查看 <em>codesign</em> 的<a href="https://opensource.apple.com/source/libsecurity_codesigning/libsecurity_codesigning-55037.15/lib/CodeSigner.cpp.auto.html" target="_blank" rel="noopener">源代码</a>发现，它会对签名数据的大小进行限制，默认限制是 9000。</p><p><code>state.mCMSSize = 9000;</code></p><p>可以通过 <code>--signature-size</code> 这个<a href="https://opensource.apple.com/source/security_systemkeychain/security_systemkeychain-55202/src/codesign.cpp.auto.html" target="_blank" rel="noopener">私有参数</a>来手动控制该限制的值，而不使用这个默认值。该参数并不是 <em>codesign</em> 的公开参数。</p><p><strong>具体用法</strong></p><p><code>codesign --signature-size 10000 -s &quot;XXX&quot;</code></p><p>网上看到有人说利用 <code>--timestamp=none</code> 可以解决该问题，但其实是治标不治本。<code>--timestamp=none</code> 本身会减少签名数据的大小，所以才看似有效果。</p><a id="more"></a><hr><p><strong>查看源代码的小窍门</strong></p><ul><li>查看：<a href="https://opensource.apple.com/source/libsecurity_codesigning/" target="_blank" rel="noopener">https://opensource.apple.com/source/libsecurity_codesigning/</a></li><li>下载：<a href="https://opensource.apple.com/tarballs/libsecurity_codesigning/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/libsecurity_codesigning/</a></li></ul><p>区别就是链接里面的 <em>source</em> 和 <em>tarballs</em>。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在更换了苹果开发者证书后，用 &lt;em&gt;codesign&lt;/em&gt; 签名时会报错：&lt;em&gt;signature too large to embed&lt;/em&gt;。大意就是签名数据太大，超出了限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根本原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过查看 &lt;em&gt;codesign&lt;/em&gt; 的&lt;a href=&quot;https://opensource.apple.com/source/libsecurity_codesigning/libsecurity_codesigning-55037.15/lib/CodeSigner.cpp.auto.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源代码&lt;/a&gt;发现，它会对签名数据的大小进行限制，默认限制是 9000。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;state.mCMSSize = 9000;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以通过 &lt;code&gt;--signature-size&lt;/code&gt; 这个&lt;a href=&quot;https://opensource.apple.com/source/security_systemkeychain/security_systemkeychain-55202/src/codesign.cpp.auto.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;私有参数&lt;/a&gt;来手动控制该限制的值，而不使用这个默认值。该参数并不是 &lt;em&gt;codesign&lt;/em&gt; 的公开参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;codesign --signature-size 10000 -s &amp;quot;XXX&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;网上看到有人说利用 &lt;code&gt;--timestamp=none&lt;/code&gt; 可以解决该问题，但其实是治标不治本。&lt;code&gt;--timestamp=none&lt;/code&gt; 本身会减少签名数据的大小，所以才看似有效果。&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Xcode" scheme="https://zongquan.wang/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Fix Bug for Interface Inspector on macOS Serria</title>
    <link href="https://zongquan.wang/2016/11/08/Fix_Bug_for_Interface_Inspector_on_macOS_Serria/"/>
    <id>https://zongquan.wang/2016/11/08/Fix_Bug_for_Interface_Inspector_on_macOS_Serria/</id>
    <published>2016-11-08T08:32:57.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前介绍过<a href="../../../../2016/04/21/Hack_Interface_Inspector/">如何破解 Interface Inspector</a>，近来把系统升级到最新的 macOS Serria 之后，发现 Interface Inspector 不 work 了。启动倒是正常，但每次 attach app 时，总是提示无法 attach，查看 system log，发现有这么一个 error：</p><p><img src="/img/Fix_Bug_for_Interface_Inspector_on_macOS_Serria/log.png" alt="log"></p><p>从 log 中看出，root cause 是 <em>mach_inject_bundle_stub</em> 去 load <code>___pthread_set_self</code> 时失败了，而这个函数本来应该是在 <em>libSystem.B.dylb</em> 这个系统库里面的。也就是说，macOS Serria 的 <em>libSystem.B.dylb</em> 已经不再有 <code>___pthread_set_self</code> 这个函数了。于是开始 google，最后在<a href="https://twitter.com/snielsen42/status/778405531383836674" target="_blank" rel="noopener">一条 Twitter</a> 上发现了咋回事，是的，<code>___pthread_set_self</code> 已经被替换成了 <code>_pthread_set_self</code>。</p><p>明白了咋回事，开始考虑怎么解决。</p><a id="more"></a><h2 id="方法-1："><a href="#方法-1：" class="headerlink" title="方法 1："></a>方法 1：</h2><p>修改 <em>mach_inject_bundle_stub</em> 的 load 指令，从旧版系统中 copy 一份老的 <em>libSystem.B.dylb</em>，然后让 <em>mach_inject_bundle_stub</em> 去 load 这个老的库。</p><h2 id="方法-2："><a href="#方法-2：" class="headerlink" title="方法 2："></a>方法 2：</h2><p>还是修改 <em>mach_inject_bundle_stub</em>，把所有调用 <code>___pthread_set_self</code> 的地方改成调用 <code>_pthread_set_self</code>。</p><p>理论上这两种方法应该都可以的吧，但是考虑到自己逆向功力不够，所以就采用了如下的正向方法 XD。</p><h1 id="方法-3："><a href="#方法-3：" class="headerlink" title="方法 3："></a>方法 3：</h1><p>我搜索了一下 <em>mach_inject_bundle_stub</em> 这个东西，发现原来是个 GitHub 上的<a href="https://github.com/wzqcongcong/mach_inject" target="_blank" rel="noopener">开源库</a>，Interface Inspector 就是用的这个库。app 会在 <code>/Library/Frameworks/mach_inject_bundle.framework</code> 这里安装这个库，而 <em>mach_inject_bundle_stub</em> 就是这个库里面的一个子 bundle。有了 source code 就好办了，只需要修改 code，然后重新编译替换掉 <em>mach_inject_bundle_stub</em> 这个 bundle 就好了。</p><p>步骤：</p><h3 id="1-fork-it"><a href="#1-fork-it" class="headerlink" title="1. fork it"></a>1. fork it</h3><h3 id="2-修改-code"><a href="#2-修改-code" class="headerlink" title="2. 修改 code"></a>2. 修改 code</h3><p><img src="/img/Fix_Bug_for_Interface_Inspector_on_macOS_Serria/github.png" alt="github"></p><h3 id="3-编译签名"><a href="#3-编译签名" class="headerlink" title="3. 编译签名"></a>3. 编译签名</h3><p>注意，这里有个小细节，app 在 load <em>mach_inject_bundle_stub</em> 这个 bundle 时，是按照 bundle id <code>com.rentzsch.mach-inject-bundle-stub</code> 来找的，所以需要把工程文件里的 bundle id 改成跟原来的 bundle id 一样。</p><h3 id="4-替换到-mach-inject-bundle-framework-里面"><a href="#4-替换到-mach-inject-bundle-framework-里面" class="headerlink" title="4. 替换到 mach_inject_bundle.framework 里面"></a>4. 替换到 <em>mach_inject_bundle.framework</em> 里面</h3><h3 id="5-顺便提一个-pull-request，老代码已经年久失修了-XD"><a href="#5-顺便提一个-pull-request，老代码已经年久失修了-XD" class="headerlink" title="5. 顺便提一个 pull request，老代码已经年久失修了 XD"></a>5. 顺便提一个 pull request，老代码已经年久失修了 XD</h3><p>完成之后，重新启动 app，可以正常 work 了！</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前介绍过&lt;a href=&quot;../../../../2016/04/21/Hack_Interface_Inspector/&quot;&gt;如何破解 Interface Inspector&lt;/a&gt;，近来把系统升级到最新的 macOS Serria 之后，发现 Interface Inspector 不 work 了。启动倒是正常，但每次 attach app 时，总是提示无法 attach，查看 system log，发现有这么一个 error：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/Fix_Bug_for_Interface_Inspector_on_macOS_Serria/log.png&quot; alt=&quot;log&quot;&gt;&lt;/p&gt;
&lt;p&gt;从 log 中看出，root cause 是 &lt;em&gt;mach_inject_bundle_stub&lt;/em&gt; 去 load &lt;code&gt;___pthread_set_self&lt;/code&gt; 时失败了，而这个函数本来应该是在 &lt;em&gt;libSystem.B.dylb&lt;/em&gt; 这个系统库里面的。也就是说，macOS Serria 的 &lt;em&gt;libSystem.B.dylb&lt;/em&gt; 已经不再有 &lt;code&gt;___pthread_set_self&lt;/code&gt; 这个函数了。于是开始 google，最后在&lt;a href=&quot;https://twitter.com/snielsen42/status/778405531383836674&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一条 Twitter&lt;/a&gt; 上发现了咋回事，是的，&lt;code&gt;___pthread_set_self&lt;/code&gt; 已经被替换成了 &lt;code&gt;_pthread_set_self&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;明白了咋回事，开始考虑怎么解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Mac" scheme="https://zongquan.wang/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Swift and Objective-C (Mix and Match)</title>
    <link href="https://zongquan.wang/2016/07/25/Swift_and_ObjectiveC_Mix_and_Match/"/>
    <id>https://zongquan.wang/2016/07/25/Swift_and_ObjectiveC_Mix_and_Match/</id>
    <published>2016-07-25T09:32:53.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 与 Objective-C 混编 （to be continued）</p><h3 id="Code-直接混编-Framework-间接混编"><a href="#Code-直接混编-Framework-间接混编" class="headerlink" title="Code 直接混编 + Framework 间接混编"></a>Code 直接混编 + Framework 间接混编</h3><hr><h2 id="lt-Code-直接混编-gt"><a href="#lt-Code-直接混编-gt" class="headerlink" title="&lt; Code 直接混编 &gt;"></a>&lt; Code 直接混编 &gt;</h2><ul><li><h4 id="在-Objective-C-code-中使用-Swift-code"><a href="#在-Objective-C-code-中使用-Swift-code" class="headerlink" title="在 Objective-C code 中使用 Swift code"></a>在 Objective-C code 中使用 Swift code</h4><p>  Objective-C project: <code>Project_C</code><br>  PRODUCT_MODULE_NAME: <code>Project_C_Product</code></p><ol><li>in Project_C’s build settings, set up <code>&quot;Embedded Content Contains Swift Code&quot;</code> to <code>&quot;YES&quot;</code>.</li><li>in Project_C’s build settings, set up <code>&quot;Objective-C Generated Interface Header Name&quot;</code> to <code>&quot;Project_C_Product-Swift.h&quot;</code>.</li><li>Swift code should use <code>@objc</code> to mark what you want to expose to Objective-C code.</li><li>in Objective-C code, <code>#import &quot;Project_C_Product-Swift.h&quot;</code>.</li></ol></li></ul><a id="more"></a><ul><li><h4 id="在-Swift-code-中使用-Objective-C-code"><a href="#在-Swift-code-中使用-Objective-C-code" class="headerlink" title="在 Swift code 中使用 Objective-C code"></a>在 Swift code 中使用 Objective-C code</h4><p>  Swift project: <code>Project_S</code><br>  PRODUCT_MODULE_NAME: <code>Project_S_Product</code></p><ol><li>in Project_S’s build settings, set up <code>&quot;Objective-C Bridging Header&quot;</code> to <code>&quot;Project_S_Product-Bridging-Header.h&quot;</code>.</li><li>in <code>&quot;Project_S_Product-Bridging-Header.h&quot;</code>, <code>#import</code> every Objective-C header you want to expose to Swift code.</li><li>in Swift code, <em>NO</em> need to <code>#import &quot;Project_C_Product-Bridging-Header.h&quot;</code>.</li></ol></li></ul><h2 id="lt-Framework-间接混编-gt"><a href="#lt-Framework-间接混编-gt" class="headerlink" title="&lt; Framework 间接混编 &gt;"></a>&lt; Framework 间接混编 &gt;</h2><ul><li><h4 id="创建-Swift-framework-给-Objective-C-code-使用"><a href="#创建-Swift-framework-给-Objective-C-code-使用" class="headerlink" title="创建 Swift framework 给 Objective-C code 使用"></a>创建 Swift framework 给 Objective-C code 使用</h4><p>framework product: <code>Framework_S</code></p><p><strong>framework’s side:</strong></p><ol><li>in Framework_S’s build settings, set up <code>&quot;Objective-C Generated Interface Header Name&quot;</code> to <code>&quot;Framework_S-Swift.h&quot;</code>.</li><li>use <code>@objc</code> to mark what you want to expose to Objective-C code.</li><li>after Framework_S is producted, its umbrella will include the <code>&quot;Framework_S-Swift.h&quot;</code> file.</li></ol><p><strong>consumer’s side:</strong></p><ol><li>in build settings, set up <code>&quot;Embedded Content Contains Swift Code&quot;</code> to <code>&quot;YES&quot;</code>.</li><li><code>@import Framework_S</code>.</li></ol></li><li><h4 id="创建-Objective-C-framework-给-Swift-code-使用"><a href="#创建-Objective-C-framework-给-Swift-code-使用" class="headerlink" title="创建 Objective-C framework 给 Swift code 使用"></a>创建 Objective-C framework 给 Swift code 使用</h4><p>framework product: <code>Framework_C</code></p><p><strong>framework’s side:</strong> nothing</p><p><strong>consumer’s side:</strong> <code>import Framework_C</code></p></li></ul><hr><h4 id="Apple-官方文档"><a href="#Apple-官方文档" class="headerlink" title="Apple 官方文档"></a><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html" target="_blank" rel="noopener">Apple 官方文档</a></h4><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 与 Objective-C 混编 （to be continued）&lt;/p&gt;
&lt;h3 id=&quot;Code-直接混编-Framework-间接混编&quot;&gt;&lt;a href=&quot;#Code-直接混编-Framework-间接混编&quot; class=&quot;headerlink&quot; title=&quot;Code 直接混编 + Framework 间接混编&quot;&gt;&lt;/a&gt;Code 直接混编 + Framework 间接混编&lt;/h3&gt;&lt;hr&gt;
&lt;h2 id=&quot;lt-Code-直接混编-gt&quot;&gt;&lt;a href=&quot;#lt-Code-直接混编-gt&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt; Code 直接混编 &amp;gt;&quot;&gt;&lt;/a&gt;&amp;lt; Code 直接混编 &amp;gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;在-Objective-C-code-中使用-Swift-code&quot;&gt;&lt;a href=&quot;#在-Objective-C-code-中使用-Swift-code&quot; class=&quot;headerlink&quot; title=&quot;在 Objective-C code 中使用 Swift code&quot;&gt;&lt;/a&gt;在 Objective-C code 中使用 Swift code&lt;/h4&gt;&lt;p&gt;  Objective-C project: &lt;code&gt;Project_C&lt;/code&gt;&lt;br&gt;  PRODUCT_MODULE_NAME: &lt;code&gt;Project_C_Product&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;in Project_C’s build settings, set up &lt;code&gt;&amp;quot;Embedded Content Contains Swift Code&amp;quot;&lt;/code&gt; to &lt;code&gt;&amp;quot;YES&amp;quot;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;in Project_C’s build settings, set up &lt;code&gt;&amp;quot;Objective-C Generated Interface Header Name&amp;quot;&lt;/code&gt; to &lt;code&gt;&amp;quot;Project_C_Product-Swift.h&amp;quot;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Swift code should use &lt;code&gt;@objc&lt;/code&gt; to mark what you want to expose to Objective-C code.&lt;/li&gt;
&lt;li&gt;in Objective-C code, &lt;code&gt;#import &amp;quot;Project_C_Product-Swift.h&amp;quot;&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Swift" scheme="https://zongquan.wang/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Hack Interface Inspector</title>
    <link href="https://zongquan.wang/2016/04/21/Hack_Interface_Inspector/"/>
    <id>https://zongquan.wang/2016/04/21/Hack_Interface_Inspector/</id>
    <published>2016-04-21T12:38:11.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在 iOSRE 上看到<a href="http://bbs.iosre.com/t/mac/3373" target="_blank" rel="noopener">一篇文章</a>，里面有讲到一个逆向 Mac app UI 的工具 <a href="http://www.interface-inspector.com/" target="_blank" rel="noopener">Interface Inspector</a>，扫了一眼，尼玛神器啊，简直就是 Reveal 的 Mac 版。上个图感受一下它的淫威吧：</p><p><img src="/img/Hack_Interface_Inspector/ii.png" alt="Interface Inspector"></p><p>这么好的工具，这么贵的价格，心痒了。好吧，凭借着<a href="../../../../2016/01/12/Hack_XtraFinder/">之前的破解经验</a>，再来搞一次吧。</p><a id="more"></a><h3 id="0-开始"><a href="#0-开始" class="headerlink" title="0. 开始"></a>0. 开始</h3><p>首先从官网下载试用版，打开 app，直接弹出一个提示框：</p><p><img src="/img/Hack_Interface_Inspector/alert.png" alt="Alert"></p><p>啊哈哈，最喜欢这么直接的打招呼了。</p><p>用 Hopper 加载完 <em>Interface Inspector</em> 后，可以直接奔着两个函数去了：</p><p><img src="/img/Hack_Interface_Inspector/launching.png" alt="Launching"></p><h3 id="1-绕过签名校验"><a href="#1-绕过签名校验" class="headerlink" title="1. 绕过签名校验"></a>1. 绕过签名校验</h3><p>首先看一下 <code>[SMAppDelegate applicationWillFinishLaunching:]</code>，里面有这么一段：</p><p><img src="/img/Hack_Interface_Inspector/will.png" alt="applicationWillFinishLaunching"></p><p>也就是说，app 启动完成之前，会调用 <code>[[NSBundle mainBundle] codeSignState]</code> 来检查 bundle 的签名是否合法（具体如何检查后面详谈）。如果不合法，会弹出一个提示框说 “Signature of the Interface Inspector is broken”，然后 app 就直接退出了。所以我们首先要绕过这个检查。</p><p>显然，<code>codeSignState</code> 这个函数并非官方 api，应该是作者自己添加的 <em>NSBundle category</em>。搜索了一下该函数名，没有找到。于是就去 app 的 <code>Frameworks</code> 目录下看看是不是由第三方库引入的。在这里有 3 个 framework：<em>DFeedback.framework</em>、<em>SMFoundation.framework</em>、<em>Sparkle.framework</em>，很明显，第一个肯定是收集用户 feedback 用的，第三个大家都知道是 update 模块，那就剩下第二个了。用 Hopper 加载 <em>SMFoundation</em>，果然搜索到了 <code>codeSignState</code> 这个函数。</p><p>在这个函数里，作者是用 <code>SecStaticCodeCheckValidityWithErrors</code> 这个官方 api 来检查签名的合法性的。具体用法可以查阅文档，这里只提一下比较重要的 2 个参数<code>staticCode</code> 和 <code>requirement</code>：<code>staticCode</code> 是待校验的 <em>code object</em>，<code>requirement</code> 则表示 <code>staticCode</code> 需要满足的校验条件。作者使用的校验条件是：<code>certificate leaf = H&quot;0E1D40082148472951C6FB2DDCD8800D82629792&quot;</code>。看到这里一开始我也蒙了，这是什么鬼。后来查阅了一下文档才明白这个用法。其实就是校验一下签名证书的叶子节点是不是 <code>H&quot;0E1D40082148472951C6FB2DDCD8800D82629792&quot;</code> 这个值，而这一串字符是签名证书的 <em>SHA1 FingerPrints</em>，由 40 个 HEX 字符组成，可以在自己的开发者证书里查到：</p><p><img src="/img/Hack_Interface_Inspector/cert.png" alt="Cert"></p><p>也就是说，如果用别人的证书重新签名该 app，而又没有同时修改这个校验条件的话，那么最终的签名就是不合法的，app 就会闪退了。所以我们需要先把这个校验条件改掉。简单，直接把这个字符串的值改成自己开发者证书里面的 <em>SHA1 FingerPrints</em> 就好了。</p><p>OK，签名校验已经绕过去了，下面就可以随意地修改 app 然后重新签名了。</p><h3 id="2-破解-License-机制"><a href="#2-破解-License-机制" class="headerlink" title="2. 破解 License 机制"></a>2. 破解 License 机制</h3><p><code>[SMAppDelegate applicationWillFinishLaunching:]</code> 已经没什么好看的了，接着看 <code>[SMAppDelegate applicationDidFinishLaunching:]</code>，里面有这么一段：</p><p><img src="/img/Hack_Interface_Inspector/did.png" alt="applicationDidFinishLaunching"></p><p>太明显了，没有 license 的话就提示用户输入序列号进行激活。顺藤摸瓜，最终找到了这么个函数 <code>[SMLicenseManager verifyLicenseWithName:code:]</code>，它就是用来验证 license 是否合法的！只要我们对它进行破解，这样随便输入任意序列号就可以激活了，啊哈哈。</p><p>简单得不能再简单了，直接用 Hopper 的 <em>Modify</em> 功能修改成 <code>mov eax, 0x1</code> <code>ret</code> 即可，也就是直接返回 <code>YES</code> 通过验证。</p><p>修改完成，重新签名，运行 app，啊哦，闪退了！</p><h3 id="3-作者的鬼点子"><a href="#3-作者的鬼点子" class="headerlink" title="3. 作者的鬼点子"></a>3. 作者的鬼点子</h3><p>看来还是有什么地方没改好。重新回去检查整个 <code>SMLicenseManager</code> 类，一个函数一个函数地检查，最终发现了这么个函数 <code>[SMLicenseManager load]</code>。作者在这里耍了一个小花招：</p><p><img src="/img/Hack_Interface_Inspector/tricky.png" alt="Tricky"></p><p>是的，我们把 <code>[SMLicenseManager verifyLicenseWithName:code:]</code> 改成了总是返回 <code>YES</code>，但是代码走到这里撞墙了，<em>Test User</em> 验证之后也返回 <code>YES</code> 了，然后 app 直接 <code>terminate:</code> 了。也就是说，作者在这里放了一个本来就是非法的 license，正常验证的话肯定是返回 <code>NO</code> 的，就不会导致直接退出了。所以我们还需要把这里的判断条件改成 <code>XXX == NO</code>，这样就没有问题了。真是淘气的作者，藏得这么深。</p><p>好了，改好，重新签名，运行 app，随便输入 license 信息，啊哈哈，注册成功！</p><p><img src="/img/Hack_Interface_Inspector/done.png" alt="Done"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在 iOSRE 上看到&lt;a href=&quot;http://bbs.iosre.com/t/mac/3373&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一篇文章&lt;/a&gt;，里面有讲到一个逆向 Mac app UI 的工具 &lt;a href=&quot;http://www.interface-inspector.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Interface Inspector&lt;/a&gt;，扫了一眼，尼玛神器啊，简直就是 Reveal 的 Mac 版。上个图感受一下它的淫威吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/Hack_Interface_Inspector/ii.png&quot; alt=&quot;Interface Inspector&quot;&gt;&lt;/p&gt;
&lt;p&gt;这么好的工具，这么贵的价格，心痒了。好吧，凭借着&lt;a href=&quot;../../../../2016/01/12/Hack_XtraFinder/&quot;&gt;之前的破解经验&lt;/a&gt;，再来搞一次吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Mac" scheme="https://zongquan.wang/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>How to install iOSOpenDev manually</title>
    <link href="https://zongquan.wang/2016/03/29/How_to_install_iOSOpenDev_manually/"/>
    <id>https://zongquan.wang/2016/03/29/How_to_install_iOSOpenDev_manually/</id>
    <published>2016-03-29T15:30:35.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/wzqcongcong/iOSOpenDev" target="_blank" rel="noopener">https://github.com/wzqcongcong/iOSOpenDev</a></p><a id="more"></a><hr><h3 id="OS-X-10-10-amp-Xcode-7"><a href="#OS-X-10-10-amp-Xcode-7" class="headerlink" title="OS X 10.10+ &amp; Xcode 7+"></a>OS X 10.10+ &amp; Xcode 7+</h3><ol><li><p><strong>Dependency</strong></p><p><code>brew install ldid dpkg</code></p></li><li><p><strong>Theos</strong></p><p><a href="https://github.com/theos/theos/wiki" target="_blank" rel="noopener">Wiki</a></p><p><a href="http://iphonedevwiki.net/index.php/Theos/Setup" target="_blank" rel="noopener">Setup</a></p></li><li><p><strong>iOSOpenDev</strong></p><p><a href="https://github.com/kokoabim/iOSOpenDev/wiki" target="_blank" rel="noopener">Wiki</a></p><p>3.1. update <strong>.zshrc</strong></p><p><code>export iOSOpenDevPath=path/to/iOSOpenDev</code></p><p><code>export iOSOpenDevDevice=</code></p><p><code>export PATH=$iOSOpenDevPath:$PATH</code></p><p>3.2. get <strong>iOSOpenDev</strong></p><ul><li><p><code>git clone --recursive https://github.com/kokoabim/iOSOpenDev.git $iOSOpenDevPath</code></p></li><li><p>copy the folder <a href="https://github.com/wzqcongcong/iOSOpenDev" target="_blank" rel="noopener"><strong>templates</strong></a> into <em>$iOSOpenDevPath</em></p></li></ul><p>this version of <strong>templates</strong> is refined by the <a href="https://github.com/kokoabim/iOSOpenDev-Xcode-Templates" target="_blank" rel="noopener">original one</a>: the <em>ShellScript</em> of <em>BuildPhases</em> in <strong>TemplateInfo.plist</strong> is changed to <code>$iOSOpenDevPath/bin/iosod --xcbp</code>. and the <em>[$iOSOpenDevPath]</em> here is not that in <em>.zshrc</em>, it is a user defined key in <strong>Base.xctemplate</strong> and <strong>Empty Project.xctemplate</strong>.</p><p>3.3. setup <strong>Xcode</strong></p><ul><li><p>copy the <a href="https://github.com/wzqcongcong/iOSOpenDev" target="_blank" rel="noopener"><strong>.xcspec</strong></a> files into <em>/Applications/Xcode/Content/Developer/Platforms/[PLATFORM_PATH]/Developer/Library/Xcode/Specifications</em> (mkdir if not existed)</p></li><li><p><code>mkdir -p /Applications/Xcode/Content/Developer/Platforms/[PLATFORM_PATH]/Developer/usr/bin</code></p></li><li><p><code>ln -fhs $iOSOpenDevPath/bin/iosod /Applications/Xcode/Content/Developer/Platforms/[PLATFORM_PATH]/Developer/usr/bin</code></p></li><li><p><code>ln -fhs $iOSOpenDevPath/bin/ldid /Applications/Xcode/Content/Developer/Platforms/[PLATFORM_PATH]/Developer/usr/bin</code></p></li></ul><p>3.4. setup <strong>SDK</strong></p><ul><li><p>modify the following key/value in <strong>[SDK_PATH]/SDKSettings.plist</strong>:</p><pre><code>DefaultProperties.CODE_SIGNING_REQUIRED =&gt; NODefaultProperties.ENTITLEMENTS_REQUIRED =&gt; NODefaultProperties.AD_HOC_CODE_SIGNING_ALLOWED =&gt; YES</code></pre></li><li><p>in Xcode 7.3, the private framework has been removed from iOS 9.3 SDK, so maybe you want to use iOS 9.2 SDK. once you copy iOS 9.2 SDK into <em>[PLATFORM_PATH]/Developer/SDKs</em>, you should also modify <strong>[PLATFORM_PATH]/Info.plist</strong> as following, or else Xcode 7.3 can not recognize iOS 9.2 SDK in project build settings:</p><pre><code>MinimumSDKVersion =&gt; 9.2</code></pre></li></ul><p>3.5. setup <strong>templates</strong></p><ul><li><code>ln -fhs $iOSOpenDevPath/templates ~/Library/Developer/Xcode/Templates/iOSOpenDev</code></li><li>open <strong>TemplateInfo.plist</strong> in <strong>Base.xctemplate</strong> and <strong>Empty Project.xctemplate</strong> with Xcode, then set the value of the user defined key <em>[iOSOpenDevPath]</em> to <em>path/to/iOSOpenDev</em>.</li></ul></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/wzqcongcong/iOSOpenDev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/wzqcongcong/iOSOpenDev&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Xcode" scheme="https://zongquan.wang/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Hack XtraFinder</title>
    <link href="https://zongquan.wang/2016/01/12/Hack_XtraFinder/"/>
    <id>https://zongquan.wang/2016/01/12/Hack_XtraFinder/</id>
    <published>2016-01-12T15:38:55.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>事情是这样的，我的系统是 OS X 10.11，就是那个有 SIP 的 10.11 😂。然后我装了一个 Finder 的插件：XtraFinder，这个插件有些功能在 10.11 下是不 work 的，所以插件作者出于好心，在检测到你的系统是 10.11 且 SIP 没有关闭的情况下，会弹出一个 alert 窗口作为提醒。</p><a id="more"></a><p><img src="/img/Hack_XtraFinder/alert.png" alt="Alert"></p><p>那么问题来了，作者检测 SIP 是否关闭的方法有个 bug，导致我明明是完全关闭了 SIP，但插件却认为 SIP 还在启用。第二个问题，这个 alert 每次重启插件（包括每次重启系统）时都会弹出来啊，出来啊，来啊，啊，搞得你每次都要去点一下确认才能将其关闭，烦的很 😒。我曾经给作者发邮件，希望他能 update 一下，只弹一次 alert 就好。当然了，作者没有鸟我。</p><p>作为偶尔会用 Hopper Disassembler 偷窥一下别人代码的我，就开始意淫能不能 hack 一下这个插件，改掉这个恶心的行为。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>Hopper Disassembler</li><li>Hex Fiend</li><li>Developer ID Application 证书</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>用 Hopper Disassembler 定位 hack point</p><p> 这个 alert 是插件一启动的时候就弹出的，所以很容易想到先去 check 一下 <code>[AppDelegate applicationDidFinishLaunching:]</code> 这个方法。Load Mach-O 文件后，直奔那个函数的伪代码：</p><p> <img src="/img/Hack_XtraFinder/hopper1.png" alt="Hopper Disassembler"></p><p> 从图中可以看到，插件作者通过 <code>csrutil status</code> 的返回结果来判断 SIP 的状态，只有返回结果中匹配到了字符串 <code>&quot;Debugging Restrictions: disabled&quot;</code> 才认为 SIP 关闭。但是，我是完全关闭 SIP 的，运行 <code>csrutil status</code> 的结果是 <code>System Integrity Protection status: disabled.</code>，显然无法匹配那个字符串，所以就被误认为是 SIP 尚未关闭。</p><p> 注意，上图中蓝色框中的内容是我修改之后的，原内容是 <code>if (rax != rcx) goto loc_100001df7;</code>，也就是当 <code>[rax rangeOfString:rdx] != NSNotFound</code> 的时候，字符串匹配成功，就跳过不弹 alert。看到这里你已经知道了，只要把条件反转就大功告成了。</p><p> 当然，除了反转判断条件之外，还可以修改那个用于匹配的字符串，比如修改成 <code>&quot;disabled&quot;</code> 就好了，都能够匹配成功。</p><p> 好了，伪代码是看明白了，下面就得看如何让这个判断条件反转了。</p><p> <img src="/img/Hack_XtraFinder/hopper2.png" alt="Hopper Disassembler"></p><p> 上图中红色框中的汇编代码对应前面分析的那块伪代码，而蓝色框中的十六进制 <code>0F 84 E1 01 00 00</code> 代表伪代码块中的最后那条命令 <code>0x0000000100001c10         je         0x100001df7</code>。<code>je</code> 这个指令表示 <em><code>如果等于则跳转到</code></em>，它的反指令是 <code>jne</code>，所以我们要做的就是把最后这条命令改为 <code>jne         0x100001df7</code>。参考一下<a href="http://neuzxy.blog.51cto.com/10270223/1716326" target="_blank" rel="noopener">这篇文章</a>，其实就是把 <code>0F 84 E1 01 00 00</code> 改为 <code>0F 85 E1 01 00 00</code>，把 4 改成 5。</p></li><li><p>用 Hex Fiend 修改 Mach-O 文件</p><p> 明白了改什么，下面就是开始操作了。用 Hex Fiend 打开 Mach-O 文件，直接查找替换即可。</p><p> <img src="/img/Hack_XtraFinder/hex1.png" alt="Hex Fiend"></p><p> 只有一点需要注意：如果直接查找 <code>0F 84 E1 01 00 00</code> 的话，可能有多处，所以为了准确定位，我们可以连同下一条命令一起来查找，如上图，我们查找 <code>0F 84 E1 01 00 00 48 8B 3D 6B 14 01 00</code>，这样就会只找到唯一的一处。</p><p> 替换完成后保存即可。</p></li><li><p>重新签名</p><p> 修改后的 Mach-O 文件是无法运行的，因为签名不对了。所以需要我们用自己的开发者证书重签一下：<code>codesign -f -s &quot;XXX 证书的 Common Name&quot; /Applications/XtraFinder.app/Contents/MacOS/XtraFinder</code>。</p><p> 大功告成，覆盖重启插件后，再也没有弹出 alert，XtraFinder 照常 work 😆。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事情是这样的，我的系统是 OS X 10.11，就是那个有 SIP 的 10.11 😂。然后我装了一个 Finder 的插件：XtraFinder，这个插件有些功能在 10.11 下是不 work 的，所以插件作者出于好心，在检测到你的系统是 10.11 且 SIP 没有关闭的情况下，会弹出一个 alert 窗口作为提醒。&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Mac" scheme="https://zongquan.wang/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Xcode Build Settings - Products Path</title>
    <link href="https://zongquan.wang/2015/11/16/Xcode_Build_Settings_Products_Path/"/>
    <id>https://zongquan.wang/2015/11/16/Xcode_Build_Settings_Products_Path/</id>
    <published>2015-11-16T12:21:54.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设一个 Project 的路径是 <code>XXX/ProjectX</code>。</p><p>当 build 完成后，我们会关注 2 个与 <strong>Product Files</strong> 有关的 settings ：</p><a id="more"></a><p><strong><code>$BUILT_PRODUCTS_DIR</code></strong> 和 <strong><code>$TARGET_BUILD_DIR</code></strong></p><p>这 2 个 settings 决定了我们 build 出来的 Products 被放置到了哪里。</p><h4 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h4><ul><li><p><strong><code>$BUILT_PRODUCTS_DIR</code></strong>：Directory path. Identifies the directory under which all the product’s files can be found. This directory contains either product files or symbolic links to them.</p></li><li><p><strong><code>$TARGET_BUILD_DIR</code></strong>：Directory path. Identifies the root of the directory hierarchy that contains the product’s files (no intermediate build files).</p></li></ul><p>乍一看好像都是用来存放 <strong>Product Files</strong> 的目录，但是它们的作用是不一样的：</p><p>刚编译完的时候，Xcode 会先把 <strong>Product Files</strong> 生成到 <strong><code>$BUILT_PRODUCTS_DIR</code></strong> 中，然后再根据具体的 configuration 来决定要不要对生成的 <strong>Product Files</strong> 进行 deploy，如果不需要 deploy，那么 <strong>Product Files</strong> 最后还是留在 <strong><code>$BUILT_PRODUCTS_DIR</code></strong> 中，如果需要 deploy，那么 <strong>Product Files</strong> 会被 move 到 <strong><code>$TARGET_BUILD_DIR</code></strong> 中，而原来的 <strong><code>$BUILT_PRODUCTS_DIR</code></strong> 中就只有 symbolic links 了。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>普通的 app 在 build 完之后，一般放置在 <code>$BUILT_PRODUCTS_DIR</code> 中即可，而对于 Xcode Plugin 来说，在 build 完之后一般会直接将其 deploy 到 Xcode 的 <strong>Plug-ins</strong> 目录中，此时 <code>$TARGET_BUILD_DIR</code> 就是 <strong>Plug-ins</strong> 目录，而 <code>$BUILT_PRODUCTS_DIR</code> 中只有 Plugin 的 symbolic links。</p><p><em>可以 clone 一下我之前写的一个<a href="https://github.com/wzqcongcong/AtAutoCompletion" target="_blank" rel="noopener">小插件</a>，build 一下看结果。</em></p><hr><h4 id="下面就看一下这-2-个路径是如何设置的"><a href="#下面就看一下这-2-个路径是如何设置的" class="headerlink" title="下面就看一下这 2 个路径是如何设置的"></a>下面就看一下这 2 个路径是如何设置的</h4><p><strong>首先解释一些相关的 settings：</strong></p><p><strong>settingName (settingDisplayNameInXcodeBuildSettings)</strong></p><ul><li><p><strong><code>$SRCROOT</code></strong>：<code>XXX/ProjectX</code></p></li><li><p><strong><code>$SYMROOT (Build Products Path)</code></strong>：Directory path. Identifies the root of the directory hierarchy that contains product files and intermediate build files. Product and build files are placed in subdirectories of this directory. 看完官方解释，我再说一下它具体如何设置。</p><ol><li><p>默认值是 <code>$SRCROOT/build</code></p></li><li><p>可以在 Xcode 的 Preferences 里面设置 <code>Build Location</code>，如下图<br><img src="/img/Xcode_Build_Settings_Products_Path/location.png" alt="Build Location"></p></li><li><p>直接在 Target 的 <code>Build Settings</code> 里面设置 <code>Build Products Path</code>，如下图<br><img src="/img/Xcode_Build_Settings_Products_Path/build_products_path.png" alt="Build Products Path"></p></li></ol><p>这 3 种设置的优先级依次递增，也就是说，如果你同时设置了 2 和 3，那么最后 build 是按照 3 的值来处理的。</p></li><li><p><strong><code>$CONFIGURATION</code></strong>：Debug、Release、自定义的等等。</p></li><li><p><strong><code>$CONFIGURATION_BUILD_DIR (Per-Configuration Build Products Path)</code></strong>：= <code>$SYMROOT/$CONFIGURATION</code>，例如 <code>XXX/ProjectX/build/Debug</code>。</p></li><li><p><strong><code>$DEPLOYMENT_LOCATION (Deployment Location)</code></strong>：Boolean value. Specifies whether product files are placed in the installation or the build directory. 它决定了要不要对 <strong>Product Files</strong> 进行 deploy。</p></li><li><p><strong><code>$SKIP_INSTALL (Skip Install)</code></strong>：Boolean value. Specifies whether to place the product at the location indicated by <em><code>$DSTROOT</code></em> or the uninstalled products directory inside the directory indicated by <em><code>$TARGET_TEMP_DIR</code></em>. 它决定了具体要把 <strong>Product Files</strong> deploy 到哪里。</p></li></ul><p><strong>下面就轮到 2 个主角了。</strong></p><ul><li><p><strong><code>$BUILT_PRODUCTS_DIR</code></strong>：= <code>$CONFIGURATION_BUILD_DIR</code> = <code>$SYMROOT/$CONFIGURATION</code> <em>（其实除了这个值，还有一种取值，不过基本不用，所以这里为了便于理解把它忽略了。详情可查阅<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/0-Introduction/introduction.html" target="_blank" rel="noopener">官方文档</a>）</em></p></li><li><p><strong><code>$TARGET_BUILD_DIR</code></strong>：</p><ol><li><p>如果 <code>$DEPLOYMENT_LOCATION</code> = <code>NO</code>，即不需要 deploy，那么 <code>$TARGET_BUILD_DIR</code> 就直接等同于 <code>$BUILT_PRODUCTS_DIR</code>。</p></li><li><p>如果 <code>$DEPLOYMENT_LOCATION</code> = <code>YES</code>，即需要 deploy，那么：</p></li></ol><p>2.1. 如果 <code>$SKIP_INSTALL</code> = <code>NO</code>，那么 <code>$TARGET_BUILD_DIR</code> = <code>$INSTALL_DIR</code> = <code>$DSTROOT/$INSTALL_PATH</code>。其中，<code>$DSTROOT</code> 的 display name 是 <code>Installation Build Products Location</code>，<code>$INSTALL_PATH</code> 的 display name 是 <code>Installation Directory</code>。另外需要注意，为了拼接出一个有效的 <code>$INSTALL_DIR</code>，<code>$INSTALL_PATH</code> 必须以 <code>/</code> 开头。</p><p>2.2. 如果 <code>$SKIP_INSTALL</code> = <code>YES</code>，那么 <code>$TARGET_BUILD_DIR</code> = <code>$TARGET_TEMP_DIR/UninstalledProducts</code>。</p><p>一般需要 deploy 的时候，都是设置 <code>$SKIP_INSTALL</code> 为 <code>NO</code>，然后设置具体的 <code>$DSTROOT</code> 和 <code>$INSTALL_PATH</code>，所以这里忽略对 <code>$TARGET_TEMP_DIR</code> 理解。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设一个 Project 的路径是 &lt;code&gt;XXX/ProjectX&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当 build 完成后，我们会关注 2 个与 &lt;strong&gt;Product Files&lt;/strong&gt; 有关的 settings ：&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Xcode" scheme="https://zongquan.wang/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>How to get File Attributes in Mac</title>
    <link href="https://zongquan.wang/2015/01/22/How_to_get_File_Attributes_in_Mac/"/>
    <id>https://zongquan.wang/2015/01/22/How_to_get_File_Attributes_in_Mac/</id>
    <published>2015-01-22T07:16:18.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Mac-File-Attributes"><a href="#Mac-File-Attributes" class="headerlink" title="Mac File Attributes"></a>Mac File Attributes</h4><p>在 Mac 开发中，想要获取 file 或者 dir 的属性，有这么4种方式：</p><a id="more"></a><ul><li><p><strong>Linux C api</strong></p><p>  <code>int lstat(const char *restrict path, struct stat *restrict buf)</code></p><p>  获取到的 stat 有如下属性：</p><pre><code>struct stat { /* when _DARWIN_FEATURE_64_BIT_INODE is defined */    dev_t           st_dev;           /* ID of device containing file */    mode_t          st_mode;          /* Mode of file (see below) */    nlink_t         st_nlink;         /* Number of hard links */    ino_t           st_ino;           /* File serial number */    uid_t           st_uid;           /* User ID of the file */    gid_t           st_gid;           /* Group ID of the file */    dev_t           st_rdev;          /* Device ID */    struct timespec st_atimespec;     /* time of last access */    struct timespec st_mtimespec;     /* time of last data modification */    struct timespec st_ctimespec;     /* time of last status change */    struct timespec st_birthtimespec; /* time of file creation(birth) */    off_t           st_size;          /* file size, in bytes */    blkcnt_t        st_blocks;        /* blocks allocated for file */    blksize_t       st_blksize;       /* optimal blocksize for I/O */    uint32_t        st_flags;         /* user defined flags for file */    uint32_t        st_gen;           /* file generation number */};</code></pre></li></ul><ul><li><p><strong>Metadata</strong></p><p>  这种方式是基于 Spotlight 的，优点是在访问大量文件时速度快，缺点是要依赖 Spotlight 功能的开启。当 Spotlight 获取到 item 的 metadata 后，就可以通过下面2种方法来获取这些 metadata：</p><ul><li><p><code>CFTypeRef MDItemCopyAttribute(MDItemRef item, CFStringRef name)</code>，metadata attribute key 格式为 kMDItemXXX，详见文档。</p></li><li><p><code>NSMetadataQuery</code>，通过执行 Spotlight 查询来获取 result，metadata attribute key 格式同上。</p><p><strong>注意</strong>，这种方式是基于 Spotlight 获取到了这些 metadata，否则拿到的值可能就是 NULL 了。</p><p><strong>另外</strong>，在 terminal 中，这种方式也有相应的命令 <code>mdls</code> 可以使用。</p></li></ul></li></ul><ul><li><p><strong>NSFileManager</strong></p><p>  通过调用 NSFileManager 的 <code>attributesOfItemAtPath:error:</code> 也可以拿到 file 的 attribute，attribute key 格式为 <code>NSFileXXX</code>，详见文档。</p></li></ul><ul><li><p><strong>NSURL</strong></p><p>  通过调用 NSURL 的 <code>getResourceValue:forKey:error:</code> 也可以拿到 file 的 attribute，resource key 格式为 <code>NSURLXXX</code>，详见文档。对比采用 NSFileManager，这种方式以 URL 的形式来访问该 file，拿到的 attribute 比 NSFileManager 也多。<strong>推荐使用。</strong></p></li></ul><h4 id="这里顺便提一下关于-delete-file-dir-的一点注意事项"><a href="#这里顺便提一下关于-delete-file-dir-的一点注意事项" class="headerlink" title="这里顺便提一下关于 delete file/dir 的一点注意事项"></a>这里顺便提一下关于 delete file/dir 的一点注意事项</h4><p>首先，NSFileManager 有一个判断 file/dir 能否删除的 api：<code>isDeletableFileAtPath:</code>，其次，还有一个负责删除的 api：<code>removeItemAtPath:error:</code>。</p><p>那么问题来了，<code>isDeletableFileAtPath:</code> 和 <code>removeItemAtPath:error:</code> 的行为不太一致！</p><p><code>removeItemAtPath:error:</code> 总是能够做出正确的行为，即能删除的话就删除，不能删除的话就不会删除。但是，<code>isDeletableFileAtPath:</code> 有时候不能做出正确的判断。</p><ul><li><p>对于 file 来说，<code>isDeletableFileAtPath:</code> 总是可以做出正确的判断，这个没问题。</p><p>  也就是说，根据 Apple 文档，当 file 的 parent dir 具有可写权限时，file 就是 deletable 的，不管 file 本身的权限如何。否则，就是 undeletable 的。</p></li><li><p>对于 dir 来说，就会出现刚才说的问题。</p><p>  理论上，根据 Apple 文档，除了判断 parent dir 的可写权限之外，<code>isDeletableFileAtPath:</code> 还会递归地去判断 child item，只有所有的 child item 都是 deletable 时，才会返回 YES。</p><p>  但是，事实上，<code>isDeletableFileAtPath:</code> 貌似没有去递归地检查 child item。</p><p>  举例说明，有这么一个 path：<user_dir>/<root_dir>/<file_no_matter_root_or_user>，path 中的名称标明了对应的权限。现在用 <code>isDeletableFileAtPath:</code> 去检查 <root_dir>。</root_dir></file_no_matter_root_or_user></root_dir></user_dir></p><p>  理论上，<root_dir> 中有个 <file_no_matter_root_or_user>，而 <file_no_matter_root_or_user> 是 undeletable 的（因为它的 parent dir <root_dir> 是 root 的，普通用户没有可写权限），所以 <root_dir> 就是 undeletable 的，所以应该返回 NO。但是 <code>isDeletableFileAtPath:</code> 返回的却是 YES。此时如果调用 <code>removeItemAtPath:error:</code> 去删除 <root_dir> 时，就会出现 error，提示没有权限。也就是说，<code>removeItemAtPath:error:</code> 跟实际情况是一致的，但 <code>isDeletableFileAtPath:</code> 却做出了错误的判断。所以对于这种情况，你需要手动地去递归调用 <code>isDeletableFileAtPath:</code> 来检查 <root_dir>。</root_dir></root_dir></root_dir></root_dir></file_no_matter_root_or_user></file_no_matter_root_or_user></root_dir></p><p>  感觉好坑啊，难道打开的姿势不对~~</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Mac-File-Attributes&quot;&gt;&lt;a href=&quot;#Mac-File-Attributes&quot; class=&quot;headerlink&quot; title=&quot;Mac File Attributes&quot;&gt;&lt;/a&gt;Mac File Attributes&lt;/h4&gt;&lt;p&gt;在 Mac 开发中，想要获取 file 或者 dir 的属性，有这么4种方式：&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Mac" scheme="https://zongquan.wang/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Just a little tips about Objective-C Block</title>
    <link href="https://zongquan.wang/2014/12/03/Just_a_little_tips_about_Block/"/>
    <id>https://zongquan.wang/2014/12/03/Just_a_little_tips_about_Block/</id>
    <published>2014-12-03T09:35:36.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>大爱 <em><code>Block</code></em>，方便易用，但是，有些坑还是需要认真对待的~~</p><p>其实问题主要是关于内存管理的。</p><a id="more"></a><h4 id="1-捕获闭包的状态"><a href="#1-捕获闭包的状态" class="headerlink" title="1. 捕获闭包的状态"></a>1. 捕获闭包的状态</h4><p>一切问题的起源：<em><code>Block</code></em> 除了包含一段可执行代码，更重要的是，它还会捕获（<em><code>capture</code></em>）其闭包内的状态。</p><p>例（1）：</p><pre><code>- (void)testMethod {    int a = 1;    void (^testBlock)(void) = ^{        NSLog(@&quot;Integer is: %i&quot;, a);    };    a = 2;    testBlock(); // output is still 1.}</code></pre><p>在定义 testBlock 时，它会捕获 a 的<strong>类型、值以及修饰符</strong>。但是，捕获只意味着对 a 做了一次<strong>快照</strong>，而并不是真正地拥有 a。也就是说，在定义 testBlock 的时候，外界 a 的值是多少，它捕获进来的值就是多少。外界对 a 值的修改不会影响到 testBlock，同样 testBlock 内部对 a 值的修改也不会影响到外界。</p><p><strong>注意</strong>：</p><ul><li><p>捕获闭包的状态是发生在 <em><code>Block</code></em> 定义的时候！而不是 <em><code>Block</code></em> 真正 run 的时候！</p></li><li><p>捕获的是<strong>类型 + 值 + 修饰符</strong>，而不单单是值！</p></li><li><p>对于标量来说，因为 <em><code>Block</code></em> 只是捕获了该变量的值，当然是无法对其进行有效地修改。而对于对象指针来说，捕获进来的是指针的值，无法修改指针的值表示不能让该指针指向另一个对象，但这不影响 <em><code>Block</code></em> 对该指针所指的对象进行操作。例如，如果例（1）中的 a 换成一个数组指针，在 <em><code>Block</code></em> 内部我们是可以做类似于 <code>[a addObject:]</code> 这种操作的，外界可以看到对指针所指对象的修改。前提是我们要在 <em><code>Block</code></em> 定义之前就要给 a 所指的对象分配好内存，即在外界 <code>NSMutableArray *a = [[NSMutableArray alloc] init]</code>，之后在 <em><code>Block</code></em> 内部就可以任意修改该对象了，而不是修改该对象的指针。</p></li></ul><h4 id="2-如何让-Block-跟外界共享捕获的内容"><a href="#2-如何让-Block-跟外界共享捕获的内容" class="headerlink" title="2. 如何让 Block 跟外界共享捕获的内容"></a>2. 如何让 Block 跟外界共享捕获的内容</h4><p>前面提到，通常 <em><code>Block</code></em> 只是对变量做了一个快照，那么如何让 block 与外界共享该变量，从而能够修改其捕获的值呢？</p><p>全靠 <em><code>__block</code></em> 这个修饰符了！</p><p>如果一个变量在声明的时候指定了 <em><code>__block</code></em> 这个修饰符，那就意味着，所有在该变量的作用域内定义的 block，都能够共享该变量。</p><p>例（2）：</p><pre><code>- (void)testMethod {    __block int a = 1;    void (^testBlock)(void) = ^{        NSLog(@&quot;Integer is: %i&quot;, a);    };    a = 2;    testBlock(); // output is 2 now.}</code></pre><p>虽然在 testBlock 定义的时候捕获到的值是1，但 a 是 <code>__block</code> 修饰的，在 testBlock run 之前，值被改成了2，所以 testBlock run 时能够共享到这一改变。同样，如果 testBlock 内部修改了 a 的值，外界也是会共享到的。</p><h4 id="3-当-Block-被-copy-时会发生什么"><a href="#3-当-Block-被-copy-时会发生什么" class="headerlink" title="3. 当 Block 被 copy 时会发生什么"></a>3. 当 Block 被 copy 时会发生什么</h4><p>首先要明白2点，<em><code>Block</code></em> 什么时候会被 copy，被 copy 到哪里？</p><p>一般情况下，<em><code>Block</code></em> 是存储在 stack 中的，当其从 stack 弹出后就消失了。例如例（1），testBlock 是在 testMethod 的 stack 中创建的，自己 run 结束后就被销毁了。这种情况下，<em><code>Block</code></em> 不会对其捕获的变量的内存管理或者生命周期有影响。</p><p>但如果 <em><code>Block</code></em> 需要被保存下来，使其在定义结束后的其它作用域下 run，那么这种情况下，它可以被 copy 到 <em><code>heap</code></em> 中进行存储。这个时候，block 被当成了 object 来看待。</p><p>比较常见的一种情景，例（3）：</p><pre><code>- (void)configureBlock {    self.block = ^{        [self doSomething];    };}</code></pre><p>block 被存储到 self.block 中供以后调用，显然是被 copy 到了 heap 中。</p><p><strong>一旦 block 被 copy，那么问题就来了！</strong></p><p><em><code>Block</code></em> 会对捕获的 self 进行 <em><code>strong reference</code></em>，这极易造成 <em><code>strong reference cycle</code></em>。因为如果该 block 不释放，那么 self 就无法释放，而 block 的释放又需要 self 先被释放，deadlock！除非在 block 用完后，<code>self.block = nil</code>，先把 block 释放掉。</p><p>只要 block 被这样定义，不管它是否在 run，问题都会一直存在，因为捕获是发生在 block 定义的时候，那个时候它就被 copy 到 heap 中了！</p><h4 id="4-weakSelf-和-strongSelf"><a href="#4-weakSelf-和-strongSelf" class="headerlink" title="4. weakSelf 和 strongSelf"></a>4. weakSelf 和 strongSelf</h4><p>为了解决例（3）中可能的 strong reference cycle 问题，就引入了 <em><code>weakSelf</code></em>。</p><p>例（4）：</p><pre><code>__weak __typeof__(self) weakSelf = self;dispatch_group_async(_operationsGroup, _operationsQueue, ^ {    [weakSelf doSomething];});</code></pre><p>weakSelf 发挥作用的关键在于，<em><code>Block</code></em> 捕获的是<strong>类型 + 值 + 修饰符</strong>，也就是说，它会捕获到 <code>__weak</code> 这个修饰符！这样 block 就不会对 self 进行 strong reference。</p><p>采用了 <code>__weak</code> 后，block 在定义的时候不会强引用 self，当 block 在真正 run 的时候，weakSelf 要么是 self，要么是 nil。之所以会为 nil，是因为此时 self 可能已经被释放了。</p><p>进一步，考虑例（5）：</p><pre><code>__weak __typeof__(self) weakSelf = self;dispatch_group_async(_operationsGroup, _operationsQueue, ^ {    __typeof__(weakSelf) strongSelf = weakSelf;    [strongSelf doSomething];    [strongSelf doSomethingElse];});</code></pre><p>又来了个 <em><code>strongSelf</code></em>！有什么用处？</p><p>是这样的，如果执行 doSomething 时，self 还在，而执行 doSomethingElse 时，self被释放了，这是不是有点不妥~~</p><p>所以 block 在 run 时，通过内部的 strongSelf 对 self 进行 strong reference，这样可以保证，如果 weakSelf 在 block 刚 run 时是 self，那么在整个 run 的期间也一直是 self，不会让 self 被释放而变成 nil。</p><p><strong>注意</strong>：这个 strongSelf 不会导致 strong reference cycle，因为它不是在 block 定义的时候被捕获进来的，它只是局部变量，只存在于 block run 的期间，当 block run 结束后，对 self 的 strong reference 就消失了。只有 weakSelf 才是在定义的时候被捕获进来的，而它又是 <code>__weak</code> 的。</p><p>关于 weakSelf 和 strongSelf，有2篇文章可以帮助理解：<a href="http://www.fantageek.com/1090/understanding-weak-self-and-strong-self/" target="_blank" rel="noopener">【1】</a> <a href="http://dhoerl.wordpress.com/2013/04/23/i-finally-figured-out-weakself-and-strongself/" target="_blank" rel="noopener">【2】</a></p><h4 id="5-补充"><a href="#5-补充" class="headerlink" title="5. 补充"></a>5. 补充</h4><ul><li><p>dispatch_async 对 block 的处理：会将 block copy 到 heap 中，因为它是需要异步处理的，所以需要将 block 存储下来。</p></li><li><p>dispatch_sync 对 block 的处理：由于是同步处理的，所以 block 只存在于当前的 stack 中，run 完就释放了，不会被存储在 heap 中。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大爱 &lt;em&gt;&lt;code&gt;Block&lt;/code&gt;&lt;/em&gt;，方便易用，但是，有些坑还是需要认真对待的~~&lt;/p&gt;
&lt;p&gt;其实问题主要是关于内存管理的。&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Mac" scheme="https://zongquan.wang/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>XPC mechanism of Mac</title>
    <link href="https://zongquan.wang/2014/11/28/XPC_mechanism_of_Mac/"/>
    <id>https://zongquan.wang/2014/11/28/XPC_mechanism_of_Mac/</id>
    <published>2014-11-27T16:44:50.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Mac 中，进程间的通信机制，除了 <em><code>NSDistributedNotification</code></em>、<em><code>Distributed Objects</code></em>，还有 XPC。XPC 可以在同一个 app 的不同 bundle 间使用，也可以在不同的 app 间使用。</p><a id="more"></a><p>XPC 机制是通过 <em><code>NSXPCConnection</code></em> 作为 channel 来通信的，每个 <em><code>NSXPCConnection</code></em> 有 <em>Client</em> 和 <em>Listener</em> 两个 endpoint。</p><h3 id="1-XPC-角色"><a href="#1-XPC-角色" class="headerlink" title="1. XPC 角色"></a>1. XPC 角色</h3><h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><p>通过 <em><code>NSXPCListener</code></em> API 来创建 Listener，并指定该 Listener 的 <em><code>NSXPCListenerDelegate</code></em>，该 delegate 需要实现的函数是 <em><code>(BOOL)listener:shouldAcceptNewConnection:</code></em>。该 delegate 函数用于决定是否响应新的 connection，并设置该 connection 的 <em><code>exportedInterface</code></em> 和 <em><code>exportedObject</code></em>。</p><ul><li><p><em><code>exportedObject</code></em>：Listener 的导出对象，提供接口供 Client 访问。</p></li><li><p><em><code>exportedInterface</code></em>：列举出 <em><code>exportedObject</code></em> 能够导出哪些可用的接口供 Client 调用，函数原型通常是：<em>`(void)doTaskWithInfo:(NSDictionary </em>)info callback:(void(^)(NSDictionary <em>dic))callback`</em>。</p></li></ul><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>Client 通过 <em><code>NSXPCConnection</code></em> API 来创建一个新的 connection，并指定该 connection 的 <em><code>remoteObjectInterface</code></em>，它代表 Listener 端的 <em><code>exportedInterface</code></em>。然后就可以通过 <em><code>remoteObjectProxyWithErrorHandler:</code></em> 来获取 Listener 端的 <em><code>exportedObject</code></em>，调用其导出的接口。Listener 在执行自己的导出函数时，可以通过调用传递进来的 callback 向 Client 端 send back 数据。</p><h4 id="NSXPCConnection"><a href="#NSXPCConnection" class="headerlink" title="NSXPCConnection"></a>NSXPCConnection</h4><p><em><code>NSXPCConnection</code></em> 的发起是单向的，只能由 Client 端到 Listener 端，因为每一个发起的 connection 必须要由 Listener 端通过 <em><code>NSXPCListenerDelegate</code></em> 函数来决定是否要进行响应。但 Client 和 Listener 都可以有自己的 <em><code>exportedObject</code></em> 和 <em><code>remoteObjectProxy</code></em>，在 connect 之后可以相互访问对方，一方的 <em><code>exportedObject</code></em> 对应另一方的 <em><code>remoteObjectProxy</code></em>。参见 Apple 文档中的图示。</p><p><strong>注意</strong>：不管是 Client 还是 Listener，设置自己的 <em><code>exportedObject</code></em> 和 <em><code>remoteObjectProxy</code></em> 必须要先于调用 <em><code>resume</code></em>。</p><h3 id="2-XPC-搭建"><a href="#2-XPC-搭建" class="headerlink" title="2. XPC 搭建"></a>2. XPC 搭建</h3><ul><li><p>同一个 app 中使用的 XPC 称为 XPC Service，在 Xcode 中可以创建 <em>XPC Service</em> 这种 target，生成的 bundle 是 .xpc。在主 app 中需要将 .xpc bundle deploy 到自己的 <em><code>Contents/XPCServices</code></em> 目录下，Mac 会在该目录中寻找相应的 .xpc bundle 去 load。</p><p>  <strong>Listener</strong>：在 <em>XPC Service</em> bundle 的代码中，需要使用 <em><code>[NSXPCListener serviceListener]</code></em> 来创建 Listener。执行 <em><code>resume</code></em> 之后永远不会 return。</p><p>  <strong>Client</strong>：在 Client 端，也就是主 app 中，需要使用 <em><code>[[NSXPCConnection alloc]   initWithServiceName:]</code></em> 来创建 connection，为其传递 <em>XPC Service</em> 的 Bundle ID。</p><p>   <strong>注意</strong>：<em>XPC Service</em> 的启动或者退出完全由 OS 自己决定，你要做的就是启动主 app，并在代码中需要的地方请求 XPC connection。举个例子，.xpc bundle 可能是在主 app 发起 XPC 请求时才被 load 和启动 XPC Service，而不是早在之前就去启动。此外，<em><code>Contents/XPCServices</code></em> 目录下的 .xpc bundle 只能由所属的主 app 调用，其它 app 无法调用。</p><p>   <strong>e.g.</strong></p><pre><code>Apple&apos;s sample code: [SandboxingAndNSXPCConnection]Apple&apos;s sample code: [AppSandboxLoginItemXPCDemo]</code></pre></li><li><p>不同 app 间的 XPC 不是通过创建 .xpc bundle 来实现的，因为前面这种方式创建的 .xpc bundle 只能被自己所属的 app 调用。而是通过创建普通的 target 来充当 XPC 的Listener。</p><p>  <strong>Listener</strong>：在 Listener app 中，需要使用 <em><code>[[NSXPCListener alloc] initWithMachServiceName:]</code></em> 来创建 Listener，为其传递自行设定的 XPC service name。执行 <em><code>resume</code></em> 之后会立即 return，所以需要自行启动 Runloop。</p><p>  <strong>Client</strong>：在 Client app 中，需要使用 <em><code>[[NSXPCConnection alloc] initWithMachServiceName:options:]</code></em> 来创建 connection，为其传递 Listener 中指定的 XPC service name。option 用于说明你的 XPC service 是否是在 admin 权限下。</p><p>  <strong>e.g.</strong> <a href="https://github.com/wzqcongcong/SMJobBlessXPC" target="_blank" rel="noopener">SMJobBlessXPC</a> | <a href="https://github.com/wzqcongcong/MyDiskCleaner" target="_blank" rel="noopener">MyDiskCleaner</a> | <a href="https://github.com/wzqcongcong/AppleTunerUpdater" target="_blank" rel="noopener">AppleTunerUpdater</a></p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Mac 中，进程间的通信机制，除了 &lt;em&gt;&lt;code&gt;NSDistributedNotification&lt;/code&gt;&lt;/em&gt;、&lt;em&gt;&lt;code&gt;Distributed Objects&lt;/code&gt;&lt;/em&gt;，还有 XPC。XPC 可以在同一个 app 的不同 bundle 间使用，也可以在不同的 app 间使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Mac" scheme="https://zongquan.wang/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Communications between sandbox apps in Mac</title>
    <link href="https://zongquan.wang/2014/11/28/Communications_between_sandbox_apps_in_Mac/"/>
    <id>https://zongquan.wang/2014/11/28/Communications_between_sandbox_apps_in_Mac/</id>
    <published>2014-11-27T16:44:04.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于 Mac 对 Sandbox 的种种限制，使得 Sandb app 间的通信方式与普通 non Sandbox app 间的通信方式有所不同，普通的通信方式，如 <em><code>NSDistributedNotification</code></em>、<em><code>Distributed Objects</code></em>、 <em><code>XPC</code></em> 等不能直接套用到 Sandbox 机制上。</p><a id="more"></a><p>Mac 引入了 <em><code>Sandbox App Group</code></em> 的机制，使得同属于一个 app group 的不同 app 间有了合适的通信方式。</p><h3 id="Sandbox-App-Group-是什么"><a href="#Sandbox-App-Group-是什么" class="headerlink" title="Sandbox App Group 是什么"></a>Sandbox App Group 是什么</h3><p>Sandbox App Group 表示由同一个 Developer ID 签名的 app group。每个 Developer ID 可以签名多个 Sandbox App Group，每个 Sandbox App Group 可以包含若干个 Sandbox app。</p><p>如果想要声明一个 Sandbox app 属于某个 Sandbox App Group，需要在该 app 的 <em><code>.entitlements</code></em> 中添加一个 <em><code>com.apple.security.application-groups</code></em> array，它的每个元素表示该 app 属于的某个 Sandbox app group，用 Group Bundle ID 表示。</p><p><strong><code>Group Bundle ID</code></strong> := <team-id>.com.company.XXX，<team-id> 其实也可以不用，但 Apple 的标准用法是以 <team-id> 作为 Group Bundle ID 的 prefix。</team-id></team-id></team-id></p><p>每个 Sandbox App Group 会在 <em><code>~/Library/Group Containers</code></em> 下生成一个对应的目录，以 Group Bundle ID 命名。该目录的结构与 Sandbox app 的 Container 目录结构相同。该目录可以被属于该 group 的所有 Sandbox app 访问，没有限制。访问该目录的方法是调用 <em><code>[[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:]</code></em>。</p><h3 id="Sandbox-App-Group-能够做什么"><a href="#Sandbox-App-Group-能够做什么" class="headerlink" title="Sandbox App Group 能够做什么"></a>Sandbox App Group 能够做什么</h3><p>借助 Sandbox App Group，有以下这么几种方式可以用来实现同 group 下的 app 间的通信。</p><h4 id="1-NSUserDefaults"><a href="#1-NSUserDefaults" class="headerlink" title="1. NSUserDefaults"></a>1. NSUserDefaults</h4><p>对于单个 Sandbox app 来说，它的 <em><code>NSUserDefaults</code></em> 只能由自己访问，别的 Sandbox app 无法访问。而有了 Sandbox App Group，每个 group 可以拥有自己的 <em><code>NSUserDefaults</code></em>，而它是可以被下属的所有 Sandbox app 共享访问的。</p><ul><li><p>创建 Group User Defaults</p><pre><code>NSUserDefaults *defaults = [[NSUserDefaults alloc] init];[defaults addSuiteNamed:&lt;Group Bundle ID&gt;];</code></pre></li><li><p>Get</p><pre><code>[defaults persistentDomainForName:];</code></pre></li><li><p>Set</p><pre><code>[defaults setPersistentDomain: forName:]</code></pre></li></ul><p>关于 <em><code>NSUserDefaults</code></em>，有一篇 <a href="http://realmacsoftware.com/blog/shared-preferences-between-sandboxed-applications" target="_blank" rel="noopener">很 NB 的文章</a> 可以学习。</p><p><strong>e.g.</strong> <a href="https://github.com/wzqcongcong/MyDiskCleaner" target="_blank" rel="noopener">MyDiskCleaner</a></p><h4 id="2-Group-Containers-目录"><a href="#2-Group-Containers-目录" class="headerlink" title="2. Group Containers 目录"></a>2. Group Containers 目录</h4><p>尽情利用吧。尽情读写吧。</p><p>比如用 <em><code>FSEventStreamRef</code></em> 来监控其下的某个目录，从而将该目录的变化通知到不同的 Sandbox app 。虽然这种通信方式有点原始~~</p><p>其实 <em><code>NSUserDefaults</code></em> 本质上就是存在于 Group Containers 里的 Preferences 目录中。</p><p><strong>e.g.</strong> <a href="https://github.com/wzqcongcong/MyDiskCleaner" target="_blank" rel="noopener">MyDiskCleaner</a></p><h4 id="3-XPC"><a href="#3-XPC" class="headerlink" title="3. XPC"></a>3. XPC</h4><p>是的，有了 Sandbox App Group，Sandbox app 间可以使用 XPC 了。<br>但使用方式需要有所注意。</p><p><strong>使用条件</strong>：</p><ul><li><p>XPC Listener 必须是位于 Helper app 中，由主 app 通过 <em><code>SMLoginItemSetEnabled</code></em> 来启动该 Helper app，从而启动 XPC Listener。</p></li><li><p>Helper app 的 Bundle ID 必须以 Group Bundle ID 作为 prefix，即 <strong><code>Helper Bundle ID</code></strong> := <group-bundle-id>.XXX</group-bundle-id></p></li><li><p>Helper app 在创建 Listener 时需要使用 <em><code>[[NSXPCListener alloc] initWithMachServiceName:]</code></em>，主 app 在创建 connection 时需要使用 <em><code>[[NSXPCConnection alloc] initWithMachServiceName:options:0]</code></em>。</p></li><li><p>XPC service name 必须等于 Helper Bundle ID。因为实际上是，在调用 <em><code>SMLoginItemSetEnabled</code></em> 启动Helper app 后，LaunchServices 自动为其注册了一个 XPC service，而 name 就是 Helper Bundle ID。</p></li></ul><p><strong>e.g.</strong> Apple Demo <em>“AppSandboxLoginItemXPCDemo”</em></p><h4 id="4-Distributed-Objects"><a href="#4-Distributed-Objects" class="headerlink" title="4. Distributed Objects"></a>4. Distributed Objects</h4><p>跟 XPC 类似，对 Distributed Objects 加些特殊设置，它也可以借助 Sandbox App Group 来实现 Sandbox app 间的通信。</p><p><strong>使用条件</strong>：</p><ul><li><p>DOServer 端要使用 <em><code>NSMachPort</code></em> 来创建 Mach Port。</p></li><li><p>DOServer 端要使用 <em><code>[[NSConnection alloc] initWithReceivePort: sendPort:]</code></em> 来初始化 connection（以后需要对该 connection 设置 rootObject，也就是 DOClient 端能够访问的 DO），给它传递之前创建的 Mach Port。不要使用 <em><code>[NSConnection defaultConnection]</code></em>。</p></li><li><p>DOServer 端要使用 <em><code>[[NSMachBootstrapServer sharedInstance] registerPort:name:]</code></em> 来注册刚创建的 Mach Port，注册用的 name 必须以 Group Bundle ID 作为 prefix，后跟自定义的 port 名称。</p><p>  <strong>注意</strong>，如果 DOServer 端位于 <em><code>SMLoginItemSetEnabled</code></em> 启动的 Helper app，那么定义的 Mach Port name 不能和该 Helper app 的 Bundle ID 同名，因为其 Bundle ID 已经被 Mac 自动用于注册 XPC Service name，会导致这里的 DO Mach Port name 注册失败。</p></li><li><p>DOClient 端要使用 <em><code>[NSConnection connectionWithRegisteredName: host:nil]</code></em> 来连接 DOServer 端，注册 name 就用之前 DOServer 端设置的 Mach Port name。</p></li></ul><p><strong>e.g.</strong> <a href="https://github.com/wzqcongcong/MyDiskCleaner" target="_blank" rel="noopener">MyDiskCleaner</a></p><h3 id="除了-Sandbox-App-Group，还有什么？"><a href="#除了-Sandbox-App-Group，还有什么？" class="headerlink" title="除了 Sandbox App Group，还有什么？"></a>除了 Sandbox App Group，还有什么？</h3><p>我们知道，在 iOS app 中，有 <em><code>URL Scheme</code></em> 这么个机制。如果某个 app 注册了某个特殊的 <em><code>URL Scheme</code></em>，那么其他 app 可以通过访问 URL 的形式来 launch 该 app。</p><p>iOS app 也是采用 Sandbox 机制的，那么在 Mac 上，该方法也是同样适用的！不管其他 app 是不是属于同一 Sandbox App Group，都可以用这种方式来 launch 该 app，并将访问的 URL 传递给该 app。而如果该 app 已经启动，那么它同样也会捕捉到被访问的 URL，从而做出响应。</p><ul><li><p>让 app 注册 URL Scheme</p><p>  在本 app 的 Info.plsit 中，添加一个 <em><code>URL types</code></em> array，它的每个元素代表一个 <em><code>URL Schemes</code></em> array，而该 array 的每个元素就是一个 URL Scheme，通常取一个特殊的名字，用于区别其它 app 的 URL Schemes。</p></li><li><p>监听自己注册的 URL Scheme</p><p>  在本 app 的 <em><code>applicationWillFinishLaunching:</code></em> delegate 函数中，利用如下代码注册一个系统 event listener：</p><pre><code>[[NSAppleEventManager sharedAppleEventManager] setEventHandler:andSelector:forEventClass:andEventID:];</code></pre><p>  callback 函数：</p><pre><code>-(void)getUrl:(NSAppleEventDescriptor *)event withReplyEvent:(NSAppleEventDescriptor*)reply{    NSURL *url = [NSURL URLWithString:[[event paramDescriptorForKeyword:keyDirectObject] stringValue]];    ...}</code></pre><p>  <strong>注意</strong>：必须要在 <em><code>applicationWillFinishLaunching:</code></em> 中注册，否则通过这种方式启动 app 后，它无法获取被访问的 URL 信息。</p></li><li><p>其它 app 访问该 URL Scheme</p><p>  在其它 app 中，构造 URL 并访问：</p><pre><code>[[NSWorkspace sharedWorkspace] openURL:[[NSURL alloc] initWithScheme:host:path:]];</code></pre></li></ul><p><strong>e.g.</strong> <a href="https://github.com/wzqcongcong/MyDiskCleaner" target="_blank" rel="noopener">MyDiskCleaner</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于 Mac 对 Sandbox 的种种限制，使得 Sandb app 间的通信方式与普通 non Sandbox app 间的通信方式有所不同，普通的通信方式，如 &lt;em&gt;&lt;code&gt;NSDistributedNotification&lt;/code&gt;&lt;/em&gt;、&lt;em&gt;&lt;code&gt;Distributed Objects&lt;/code&gt;&lt;/em&gt;、 &lt;em&gt;&lt;code&gt;XPC&lt;/code&gt;&lt;/em&gt; 等不能直接套用到 Sandbox 机制上。&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Mac" scheme="https://zongquan.wang/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>How to add Login item for Mac</title>
    <link href="https://zongquan.wang/2014/11/27/How_to_add_Login_item_for_Mac/"/>
    <id>https://zongquan.wang/2014/11/27/How_to_add_Login_item_for_Mac/</id>
    <published>2014-11-27T14:35:05.000Z</published>
    <updated>2017-11-02T12:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Mac OS 中，有许多机制可以用于添加 Login item，不同的 Login item 类型需要用不同的方式来添加，每种方式都有自己的工作流程，应用范围，以及最终的表现效果。</p><a id="more"></a><p>从开发者的角度来看，可以分成两大类，<strong>一类</strong>是在代码中通过调用 Mac 的 API 来添加，由 Mac 来自动管理 Login item；<strong>另一类</strong>是开发者直接拿 File System 开刀，手动控制。</p><h2 id="类型-1"><a href="#类型-1" class="headerlink" title="类型 1"></a>类型 1</h2><h3 id="1-Service-Management-framework"><a href="#1-Service-Management-framework" class="headerlink" title="1. Service Management framework"></a>1. Service Management framework</h3><ul><li><p><strong>API</strong>: <strong><code>SMLoginItemSetEnabled</code></strong></p></li><li><p><strong>How</strong>: main app 的 <em><code>Contents/Library/LoginItems</code></em> 目录下包含一个 helper app，该 helper app 将作为 Login item 由 Mac 启动。</p><p>  也就是说，main app 的 Build Phases 中需要添加一个 Copy Files 阶段，将 helper app deploy 到自己的上述目录下，然后，在 main app 的代码中，通过调用 <em><code>SMLoginItemSetEnabled:YES</code></em> 将 helper app 启动，同时设置成 Login item。同样，禁用该 helper app 也是由 main app 在代码中控制，调用 <em><code>SMLoginItemSetEnabled:NO</code></em> 来实现，将会杀掉 helper app，并取消 Login item。</p><p>  main app 会传递给 <em><code>SMLoginItemSetEnabled</code></em> 需要启动的 helper app 的 Bundle ID，然后该 API 就会在 <em><code>Contents/Library/LoginItems</code></em> 中寻找该 helper app，执行相应的动作。</p><p>  <strong>注意</strong>：helper app 的 <code>Info.plist</code> 中需要设置 <em><code>LSUIElement</code></em> 或者 <em><code>LSBackgroundOnly</code></em> 。</p></li><li><p>该方法添加的 Login item 对用户是不可见的，在 System Preference 中也看不到。</p></li><li><p><strong>e.g.</strong> <a href="https://github.com/wzqcongcong/MyDiskCleaner" target="_blank" rel="noopener">MyDiskCleaner</a></p></li></ul><h3 id="2-SMJobBless"><a href="#2-SMJobBless" class="headerlink" title="2. SMJobBless"></a>2. SMJobBless</h3><ul><li><p><strong>API</strong>: <strong><code>AuthorizationCreate</code> <code>SMJobBless</code></strong></p></li><li><p><strong>How</strong>: 同样也是一个 main app 和一个 helper app，helper app 一般是 Command Line Tool 类型的 target。helper app deploy 到 main app 的 <em><code>Contents/Library/LaunchServices</code></em> 目录下，由 main app 将其注册到 Mac 的 <em><code>LaunchDaemon</code></em> 中，实现自启动。</p><p>  main app 代码中首先需要调用 <em><code>AuthorizationCreate</code></em> 来获取 admin 权限，然后将获取到的权限连同 helper app 的 Bundle ID 一起传给 <em><code>SMJobBless</code></em>，<em><code>SMJobBless</code></em> 会将该 helper app 复制到 Mac 的 <em><code>/Library/PrivilegedHelperTools</code></em> 目录下，同时在 <em><code>/Library/LaunchDaemons</code></em> 目录下生成一个相应的 plist 文件，Mac 启动时，由 <em><code>launchctl</code></em> load 该 plist，从而 load helper app。</p><p>  <strong>注意</strong>：helper app 这个 target 需要一些特殊处理。首先，需要为其新建一个 <em><code>&lt;Bundle ID&gt;-Launchd.plist</code></em>，该 plist 中会写明如何被 <em><code>launchctl</code></em> load，然后，在 Build Settings 中需要设置 <em><code>Other Linker Flags</code></em> 的值，在其中写入 helper app 的 Info.plist 和上面的 Launchd.plist。这样，在编译出的 target 可执行文件中，会有一段特殊的代码区记录着它的 Info.plist 和 Launchd.plist 信息。<em><code>SMJobBless</code></em> 调用后在 <em><code>/Library/LaunchDaemons</code></em> 目录生成的 plist 文件就是直接从 target 可执行文件中读取到的。</p><p>  <strong>注意</strong>：<em><code>SMJobBless</code></em> 执行时，如果 <em><code>/Library/PrivilegedHelperTools</code></em> 目录下已经有了相同 Bundle ID 的 helper app，那么除非其 <em><code>CFBundleShortVersion</code></em> 不同，否则是不会重新覆盖的。所以当 helper app 代码发生改变时，为了希望能 deploy 新的 helper app，需要同时更新其 <em><code>CFBundleShortVersion</code></em>，这样 <em><code>SMJobBless</code></em> 才会将新的有效的 helper app deploy 到 <em><code>/Library/PrivilegedHelperTools</code></em> 目录下，并将其 load 起来。</p></li><li><p>该方法添加的 Login item 对用户是可见的，可执行文件和相应的 plist 文件的位置如上所述。用户可以手动执行 <em><code>launchctl</code></em> 来 load/unload。该方法不仅添加了 Login item，而且还实现了提权操作，也就是说，helper app 将会以 admin 权限来运行。</p></li><li><p><strong>e.g.</strong> <a href="https://github.com/wzqcongcong/AppleTunerUpdater" target="_blank" rel="noopener">AppleTunerUpdater</a></p></li></ul><h3 id="3-OS-Launch-Services"><a href="#3-OS-Launch-Services" class="headerlink" title="3. OS Launch Services"></a>3. OS Launch Services</h3><ul><li><p><strong>API</strong>: <strong><code>LSSharedFileList</code> 系列</strong></p></li><li><p><strong>How</strong>: 貌似过时了？文档中没有？StackOverflow 中有相关帖子介绍<a href="http://stackoverflow.com/questions/5449135/how-can-a-cocoa-application-add-itself-as-a-global-login-item" target="_blank" rel="noopener">【1】</a> <a href="http://stackoverflow.com/questions/14889956/launch-cocoa-application-for-all-users-during-login" target="_blank" rel="noopener">【2】</a></p></li><li><p>该方法添加的 Login item 对用户是可见的，在 System Preference 的 Users &amp; Groups 中可以查看到相应的 Login item，用户可以选择启用或者禁用。</p></li></ul><h2 id="类型-2"><a href="#类型-2" class="headerlink" title="类型 2"></a>类型 2</h2><h3 id="4-LaunchAgents-LaunchDaemons-目录"><a href="#4-LaunchAgents-LaunchDaemons-目录" class="headerlink" title="4. LaunchAgents / LaunchDaemons 目录"></a>4. LaunchAgents / LaunchDaemons 目录</h3><p>编写需要的 plist 文件，写明如何被 <em><code>launchctl</code></em> load，然后将 plist 放置到 <em><code>LaunchAgents / LaunchDaemons</code></em> 目录。</p><ul><li>~/Library/LaunchAgents    （user 权限，只对当前 user 有效）</li><li>/Library/LaunchAgents        （root 权限，对所有 user 有效）</li><li>/Library/LaunchDaemons    （root 权限，系统级别）</li></ul><hr><p>总结：</p><p>对于 non Sandbox app 来说，上述4种方法都是可行的。<br>对于 Sandbox app 来说，方法1适用，方法4写入 <em><code>~/Library/LaunchAgents</code></em> 也适用，其它方法不适用。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Mac OS 中，有许多机制可以用于添加 Login item，不同的 Login item 类型需要用不同的方式来添加，每种方式都有自己的工作流程，应用范围，以及最终的表现效果。&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="https://zongquan.wang/categories/Development/"/>
    
    
      <category term="Mac" scheme="https://zongquan.wang/tags/Mac/"/>
    
  </entry>
  
</feed>
